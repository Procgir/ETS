## Цели и задачи
Сформировать представление о том, что такое автоматизированные тесты с использованием библиотек XUnit, FluentAssertions
- реализовать Unit Tests
- реализовать Integration  Tests
- реализовать Functional Tests
- реализовать Architectural Tests

---
## Теория
### Введение
Автоматизированные тесты (автотесты) — это неотъемлемая часть современного процесса разработки программного обеспечения. Они представляют собой программные сценарии, которые автоматически проверяют работоспособность приложения, выявляют ошибки и обеспечивают стабильность продукта на всех этапах разработки.

Для чего они нужны?
- **Ускорение разработки и повышения качества** Автотесты позволяют быстро проверять функциональность приложения, что способствует более быстрой разработке и повышению качества продукта. 
- **Снижение человеческого фактора** Автоматизация тестирования исключает влияние человеческого фактора, такого как усталость или невнимательность, что повышает точность и надежность тестирования. 
- **Повышение покрытия кода** Автотесты позволяют покрыть большее количество сценариев, включая те, которые сложно протестировать вручную, что способствует более полному тестированию приложения.
- **Документация и понимание кода** Автотесты служат своего рода документацией, показывая, как должна работать та или иная часть системы, что облегчает понимание кода для новых членов команды.

Автоматизация тестирования оправдана в следующих случаях:
- **Частые изменения в коде:** Когда функциональность часто меняется, автотесты помогают быстро проверить, не нарушены ли старые функции.
- **Повторяющиеся задачи:** Автоматизация рутинных проверок позволяет сэкономить время и ресурсы.
- **Критические сценарии:** Для проверки важных бизнес-сценариев, где ошибки могут привести к значительным последствиям.
- **Непрерывная интеграция:** Интеграция автотестов в процесс CI/CD позволяет автоматически проверять код при каждом изменении.

Автоматизация тестирования может быть нецелесообразной в следующих случаях:
- **Редкие изменения функционала:** Если функциональность меняется редко, разработка и поддержка автотестов может быть затратной.
- **Сложные сценарии:** Некоторые сложные сценарии могут быть трудны для автоматизации и требуют ручного тестирования.
- **Срочные сроки:** Когда необходимо быстро протестировать функциональность, ручное тестирование может быть более эффективным.

### Виды
#### 1. **Unit-тесты (модульные тесты)**

**Цель:** Проверка работы отдельных методов или классов в изоляции от остальной системы.

**Особенности:**
- Изолируют тестируемый код от внешних зависимостей с помощью моков или заглушек.
- Быстро выполняются и легко интегрируются в процесс разработки.
- Позволяют выявить ошибки на ранних стадиях разработки.

**Применение в ASP.NET Core:**
- Тестирование бизнес-логики, сервисов, утилит и вспомогательных классов.
- Использование фреймворков, таких как xUnit, NUnit или MSTest.

```
public class CalculatorTests
{
    [Fact]
    public void Add_TwoNumbers_ReturnsCorrectSum()
    {
        var calculator = new Calculator();
        var result = calculator.Add(2, 3);
        Assert.Equal(5, result);
    }
}
```

#### 2. **Integration-тесты (интеграционные тесты)**
**Цель:** Проверка взаимодействия между компонентами системы, таких как базы данных, API и другие сервисы.

**Особенности:**
- Тестируют взаимодействие нескольких компонентов системы.
- Могут включать реальные или имитированные внешние зависимости.
- Помогают выявить проблемы на уровне взаимодействия компонентов.

**Применение в ASP.NET Core:**
- Тестирование контроллеров, middleware, взаимодействия с базой данных.
- Использование `WebApplicationFactory` для создания тестового веб-хоста и `TestServer` для отправки HTTP-запросов.

```
public class WeatherForecastControllerTests : IClassFixture<WebApplicationFactory<Startup>>
{
    private readonly HttpClient _client;

    public WeatherForecastControllerTests(WebApplicationFactory<Startup> factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task Get_ReturnsWeatherForecast()
    {
        var response = await _client.GetAsync("/weatherforecast");
        response.EnsureSuccessStatusCode();
        var forecasts = await response.Content.ReadAsAsync<IEnumerable<WeatherForecast>>();
        Assert.NotEmpty(forecasts);
    }
}
```
#### 3. **Functional-тесты (функциональные тесты)**

**Цель:** Проверка выполнения бизнес-сценариев и пользовательских потоков.

**Особенности:**
- Охватывают полный путь пользователя от начала до конца.
- Могут включать взаимодействие с UI, API, базой данных и другими компонентами.
- Помогают убедиться, что система выполняет требуемые функции.

**Применение в ASP.NET Core:**
- Тестирование пользовательских сценариев, таких как регистрация, авторизация, оформление заказа.
- Использование инструментов, таких как Selenium или Playwright, для автоматизации взаимодействия с UI.
```
public class UserRegistrationTests : IClassFixture<WebApplicationFactory<Startup>>
{
    private readonly HttpClient _client;

    public UserRegistrationTests(WebApplicationFactory<Startup> factory)
    {
        _client = factory.CreateClient();
    }

    [Fact]
    public async Task Register_NewUser_ReturnsSuccess()
    {
        var response = await _client.PostAsJsonAsync("/api/users/register", new { Username = "test", Password = "password" });
        response.EnsureSuccessStatusCode();
        var user = await response.Content.ReadAsAsync<User>();
        Assert.Equal("test", user.Username);
    }
}
```
#### 4. **Architectural-тесты (архитектурные тесты)**

**Цель:** Проверка соблюдения архитектурных принципов и ограничений.

**Особенности:**
- Проверяют структуру кода, зависимости между компонентами, соблюдение слоёв и модулей.
- Помогают предотвратить архитектурные деградации и нарушения принципов SOLID.
- Могут включать статический анализ кода и проверки на уровне сборок.

**Применение в ASP.NET Core:**
- Проверка слоёв приложения (например, разделение на API, сервисы, репозитории).
- Использование инструментов, таких как ArchUnitNET или NDepend, для анализа архитектуры.

```
public class ArchitectureTests
{
    [Fact]
    public void Controllers_ShouldNotDependOnDataAccess()
    {
        var controllerTypes = Assembly.Load("MyApp.Controllers").GetTypes();
        var dataAccessTypes = Assembly.Load("MyApp.DataAccess").GetTypes();
        foreach (var controller in controllerTypes)
        {
            foreach (var dataAccess in dataAccessTypes)
            {
                Assert.DoesNotContain(controller.GetInterfaces(), i => i == dataAccess);
            }
        }
    }
}
```
🧩 Рекомендации по организации тестов в ASP.NET Core
- **Используйте подход "пирамиды тестирования"**: больше юнит-тестов, меньше интеграционных и функциональных тестов.
- **Интегрируйте тесты в процесс CI/CD**: автоматический запуск тестов при каждом изменении кода.
- **Используйте мок-объекты и заглушки**: для изоляции тестируемых компонентов.
- **Регулярно анализируйте архитектуру**: с помощью статического анализа и архитектурных тестов.

| Характеристика                         | **NUnit**                                    | **xUnit**                                          | **FluentAssertions**                                                             |
| -------------------------------------- | -------------------------------------------- | -------------------------------------------------- | -------------------------------------------------------------------------------- |
| **Тип**                                | Фреймворк для тестирования                   | Фреймворк для тестирования                         | Библиотека для расширения возможностей утверждений в тестах                      |
| **Синтаксис утверждений**              | `Assert.AreEqual(expected, actual)`          | `Assert.Equal(expected, actual)`                   | `actual.Should().Be(expected)`                                                   |
| **Поддержка параметризации**           | Да, через атрибуты `[TestCase]`              | Да, через атрибуты `[Theory]` и `[InlineData]`     | Нет                                                                              |
| **Поддержка параллельного выполнения** | Да, с помощью атрибута `[Parallelizable]`    | Да, по умолчанию                                   | Зависит от используемого фреймворка тестирования                                 |
| **Интеграция с CI/CD**                 | Хорошая поддержка в различных CI/CD системах | Отличная интеграция с современными CI/CD системами | Не влияет напрямую, но улучшает читаемость тестов, что облегчает поддержку CI/CD |
| **Поддержка платформ**                 | .NET Framework, .NET Core, Xamarin, Mono     | .NET Framework, .NET Core, Mono                    | Используется совместно с NUnit или xUnit, поддерживает те же платформы           |
| **Сообщество и документация**          | Широкое сообщество, обширная документация    | Активное сообщество, хорошая документация          | Популярная в сообществе, документация доступна на официальном сайте и GitHub     |
|                                        |                                              |                                                    |                                                                                  |
- **NUnit**: Популярный фреймворк для юнит-тестирования, известен своей гибкостью и поддержкой различных атрибутов для настройки тестов. Подходит для проектов, где требуется сложная настройка тестов и использование различных атрибутов для параметризации и настройки.
- **xUnit**: Современный фреймворк, ориентированный на простоту и поддержку параллельного выполнения тестов. Предпочтителен для новых проектов, особенно тех, которые используют современные подходы к разработке и тестированию.
- **FluentAssertions**: Библиотека, расширяющая возможности утверждений в тестах, делая их более читаемыми и выразительными. Используется совместно с NUnit или xUnit для улучшения качества тестов.
### Дополнительные материалы
[Metanit полное руководство по C#](https://metanit.com/sharp/tutorial/1.1.php)
[Metanit полное руководство по Asp.Net Core](https://metanit.com/sharp/aspnet6/)

[Рефакторинг гуру](https://refactoring.guru/ru/refactoring)
[Паттерны проектирования](https://refactoring.guru/ru/design-patterns)

[Паттерный проектирования](https://codelibrary.info/books/c-sharp/patterny-proektirovaniya-dlya-c-i-platformy-net-core?highlight=WyJjIl0=)
[Рефакторинг Улучшение существующего кода](https://codelibrary.info/books/dlya-programmistov/refaktoring)

[Простое объектно-ориентированное проектирование](https://codelibrary.info/books/dlya-programmistov/prostoe-obektno-orientirovannoe-proektirovanie)
[Проектирование API](https://codelibrary.info/books/dlya-programmistov/proektirovanie-arkhitektury-api)
[Искусство чистого кода](https://codelibrary.info/best-books/c-sharp?highlight=WyJjIl0=)

[Архитектурные паттерны](https://github.com/RefactoringGuru/design-patterns-csharp)
#### Полезные ссылки
[Дорожные карты Backend](https://roadmap.sh/backend)
[Дорожная карта Asp.Net Core](https://roadmap.sh/aspnet-core)
[Алгоритмы](https://neetcode.io/roadmap)

https://www.youtube.com/watch?v=w8rRhAup4kg
https://www.youtube.com/watch?v=_8yZYhAkQjQ
https://www.youtube.com/watch?v=pFKwmEdwZZQ
https://neetcode.io/roadmap

---
## Практика
Цель - научиться писать AAA автотесты для простых веб-сервисов
- добавить Unit тесты
- добавить Integration тесты
- добавить Functional тесты
- добавить Architectural тесты

---
## Упражения
При внесение изменений всегда приходится тестировать приложение, чтобы выявить ошибки, баги, которые могли возникнуть в процессе разработки. Ручное тестирование утомительное и рутинное занятие. Для решение этой проблемы существует автоматизированное тестирование. Реализуем базовые тесты на существующую логику.
### 1
Реализуйте UnitTests для слоя Домена

2
Реализуйте UnitTests для слоя Приложения

3
Реализуйте IntegrationTests для Приложения

4
Реализуйте FunctionalTests на WebApi

5
Реализуйте ArchitecturalTests, чтобы вашим проектом было легко управлять

---
## FAQ
Если у вас возникли вопросы по занятию или общие обратитесь к [FAQ](https://docs.google.com/spreadsheets/d/1_n-wfeDpjv3-NcWxreu7minH0JQ-ooQb9B1KtNMU0eI/edit?usp=sharing)
Возможно ответ уже находится там

Если ответа на вопрос там нет. Напишите его и я обязательно дам ответ

**Инструкция**:
1. Запросите права доступа к таблице, если у вас нет доступа
2. Если вопрос по конкретному занятию, тогда зайдите во вкладку с **названием занятия**, по которому у вас возник вопрос, иначе зайдите на вкладку **Общие**
3. Напишите Вопрос в столбце **Вопрос**
4. Напишите Фамилию Имя в столбце **Автор**
5. Повторите действия
	1. Укажите Статус Ожидает 
	2. Дождитесь ответа. У вопроса будет статус Ответ дан
	3. Если ответ требует уточнения перевидте вопрос в статус Требует уточнения и напишите комментарий в столбце Комментарий
	4. Повторите, пока не получите ответ на свой вопрос
6. Переведите ответ в статус Завершен
7. Если ответ вам помог разобраться, увеличьте число в колонке **Лайки**, это поможет понять насколько эти вопросы общие и вынести ответы в материалы курса

Спасибо, что оставили вопрос, благодаря этому курс может стать лучше

---
## Обратная связь
**Обязательная обратная связь**
Для автоматизации процесса контроля за работой учеников и улучшения курса необходимо **обязательно** оставить [обратную связь по курсу](https://docs.google.com/forms/d/e/1FAIpQLSfOZTyNNNA-GDpWapoh7g_fmHYYpO8_1ZnoWsDyQTubAHvrFw/viewform?usp=dialog)
Обратная связь обязательно с точки зрения факта отправки, но нет цели заставить вас что-то писать в ней, если вам нечего сказать.

**Необязательная обратная связь** (АНОНИМНАЯ)
Если вам есть, что сказать по занятиям, но вы по каким-то причинам не готовы этим поделиться в обязательной форме обратной связи, то буду очень благодарен, если оставите ее в [анонимной обратной связи](https://docs.google.com/forms/d/e/1FAIpQLSfvVEkllf7gLIlkZLLwKXgkLVbj2sHrX4wMT4dcCeICE-K1rQ/viewform?usp=dialog)


