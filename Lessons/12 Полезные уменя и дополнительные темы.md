## Цели и задачи
Освоить навыки  решения задач при разработке веб-сервисов и сформировать представление о веб-разработке с точки зрения построения системы
- навык непрерывного обучения и практики
- поиск информации
- декомпозиция и планирование работы над задачами
- изучение проекта и погружение в механику работы
- рефакторинг
- траблшутинг/отладка
- анализ, предложение, выбор между различными решениями в ограничивающем контексте
- изменение текущего функционала
- доработка нового функционала
- тестирование и качественный релиз
- Доп. темы: Брокеры сообщений (RabbitMQ, Kafka), Балансировщик нагрузки (HAProxy), Reverse Proxy (nginx), API Gateway, Сбор Метрик (Prometheus)/Отображение (Grafana/ELK), CI/CD, Поисковые движки (Elastic) и другое

---
## Теория
Разработка сервисов — это сложный процесс, требующий не только умения писать код, но и глубокого понимания архитектуры, бизнес-логики и процессов, обеспечивающих стабильность и масштабируемость системы. Современный разработчик должен уметь не только создавать новый функционал, но и эффективно работать с уже существующей кодовой базой: анализировать её, находить узкие места, исправлять ошибки и вносить изменения, не нарушая работу сервиса.

Ключевые навыки:
1. **Навык непрерывного обучения и практики**
2. **Поиск информации**
3. **Декомпозиция и планирование работы над задачами**
4. **Изучение проекта и погружение в механику работы**
    - Как быстро разобраться в новой кодовой базе.
    - Понимание архитектуры и потоков данных.
    - Работа с документацией и коммуникация с командой.
5. **Рефакторинг**
    - Когда и зачем нужен рефакторинг.
    - Принципы чистого кода (SOLID, DRY, KISS).
    - Безопасное улучшение кода без поломки функционала.
6. **Траблшутинг и отладка**
    - Методы поиска и диагностики ошибок.
    - Инструменты отладки (логгирование, профилирование, дебаггеры).
    - Анализ инцидентов и post-mortem разборы.
7. **Анализ, предложение и выбор решений**
    - Как оценивать разные варианты реализации.
    - Trade-off: производительность vs. читаемость, скорость разработки vs. масштабируемость.
    - Принятие решений в условиях ограничений (сроки, ресурсы, legacy-код).
8. **Изменение текущего функционала**
    - Как безопасно модифицировать работающий код.
    - Обратная совместимость и graceful degradation.
    - Стратегии постепенного обновления (feature flags, canary-релизы).
9. **Доработка нового функционала**
    - Проектирование API и взаимодействия компонентов.
    - Интеграция с существующей системой.
    - Оптимизация и обеспечение масштабируемости.
10. **Тестирование и качественный релиз**
    - Виды тестирования (unit, интеграционные, e2e, нагрузочные).
    - CI/CD и автоматизация проверок.
    - Стратегии деплоя и отката изменений.


Каждый из этих навыков критически важен для разработчика, работающего над сервисами.
### Брокеры сообщений (RabbitMQ, Kafka)
Брокеры сообщений — это промежуточное ПО, предназначенное для обмена сообщениями между компонентами распределённых систем. Они обеспечивают асинхронную коммуникацию, повышают отказоустойчивость и масштабируемость приложений.

Два популярных брокера сообщений — **RabbitMQ** и **Apache Kafka** — имеют разные архитектуры и сценарии применения.

#### **1. RabbitMQ**

**Общая характеристика**
- **Тип**: Брокер сообщений (Message Broker) на основе протокола **AMQP** (Advanced Message Queuing Protocol).
- **Модель**: Работает по принципу **очередей** (queues) и обменников (exchanges).
- **Гарантии доставки**: Подтверждения (acknowledgments), транзакции, persistence (сохранение на диск).
- **Языки**: Поддерживает множество языков (Python, Java, Go, .NET и др.).

**Архитектура**
- **Producer** → **Exchange** → **Queue** → **Consumer**
    - **Exchange** определяет, куда направить сообщение (direct, fanout, topic, headers).
    - **Queue** хранит сообщения до обработки Consumer'ом.
    - **Consumer** подписывается на очередь и обрабатывает сообщения.
**Плюсы**

✅ Гибкость (разные типы роутинга).  
✅ Поддержка транзакций и подтверждений.  
✅ Хорош для **RPC**, **фоновых задач**, **микросервисов**.

**Минусы**

❌ Менее производителен при высокой нагрузке (по сравнению с Kafka).  
❌ Нет встроенной репликации (требует настройки кластера).
**Когда использовать?**
- Асинхронная обработка задач (например, отправка email).
- Балансировка нагрузки между Worker'ами.
- Микросервисная архитектура.

#### **2. Apache Kafka**

**Общая характеристика**
- **Тип**: Распределённый **журнал событий (event log)**.
- **Модель**: Работает с **топиками (topics)**, разбитыми на **партиции**.
- **Гарантии доставки**: Сообщения хранятся долго (можно перечитывать).
- **Производительность**: Очень высокая (миллионы сообщений в секунду).

**Архитектура**

- **Producer** → **Topic (Partitions)** → **Consumer Group**
    - **Топик** — это категория сообщений (например, `user_actions`).
    - **Партиции** позволяют параллельно обрабатывать данные.
    - **Consumer Group** — группа потребителей, читающих данные.
**Плюсы**

✅ Высокая пропускная способность.  
✅ Хранение данных длительное время (логи).  
✅ Горизонтальная масштабируемость.

**Минусы**

❌ Сложнее в настройке и администрировании.  
❌ Не подходит для **RPC** и короткоживущих задач.

**Когда использовать?**
- Обработка потоковых данных (например, аналитика в реальном времени).
- Event Sourcing и CQRS.
- Логирование и аудит.

**Сравнение RabbitMQ и Kafka**

|Критерий|RabbitMQ|Kafka|
|---|---|---|
|**Модель**|Очереди (Point-to-Point, Pub/Sub)|Журнал событий (Log-Based)|
|**Скорость**|Средняя (десятки тыс. msg/sec)|Очень высокая (миллионы msg/sec)|
|**Хранение**|После обработки удаляется|Хранится долго (настраивается)|
|**Гарантии**|ACK, транзакции|At-least-once, Exactly-once (Kafka ≥ 0.11)|
|**Использование**|Фоновые задачи, RPC|Потоковая обработка, аналитика|

#### **Вывод**
- **RabbitMQ** лучше подходит для **задач, требующих гибкой маршрутизации** (например, микросервисы, фоновые задачи).
- **Kafka** идеален для **высоконагруженных потоков данных** (логи, события, аналитика).

Выбор зависит от конкретной задачи: если нужна простота и гибкость — RabbitMQ, если масштабируемость и потоковая обработка — Kafka.
[Статья](https://habr.com/ru/companies/innotech/articles/698838/)
[Статья2](https://habr.com/ru/companies/yandex_praktikum/articles/700608/)
### Балансировщик нагрузки (HAProxy)
**Балансировка нагрузки** — это метод распределения сетевого трафика между несколькими серверами для оптимизации загрузки, повышения отказоустойчивости и улучшения производительности системы.

#### **1. Зачем нужна балансировка нагрузки?**
- **Повышение доступности** – если один сервер падает, трафик перенаправляется на другие.
- **Увеличение производительности** – запросы распределяются между серверами, предотвращая перегрузку.
- **Масштабируемость** – можно добавлять новые серверы без простоев.
- **Геораспределение** – запросы можно направлять на ближайшие серверы (CDN, Anycast).

#### **2. Как работает балансировка нагрузки?**
1. **Клиент** отправляет запрос (HTTP, TCP и др.).
2. **Балансировщик** (например, HAProxy, Nginx, AWS ALB) принимает запрос.
3. **Алгоритм балансировки** выбирает сервер из пула (например, Round Robin, Least Connections).
4. **Запрос перенаправляется** на выбранный сервер.
5. **Сервер обрабатывает запрос** и возвращает ответ клиенту.
#### **3. Виды балансировки нагрузки**
**1. По уровню сетевой модели OSI**

|Тип|Уровень OSI|Пример использования|
|---|---|---|
|**L4 (Transport)**|Транспортный (TCP/UDP)|Балансировка баз данных (PostgreSQL, Redis), VoIP, игровые серверы.|
|**L7 (Application)**|Прикладной (HTTP/HTTPS)|Веб-сайты, API, микросервисы.|

**2. По алгоритму распределения**

|Алгоритм|Описание|
|---|---|
|**Round Robin**|Запросы по очереди распределяются между серверами.|
|**Least Connections**|Запрос отправляется на сервер с наименьшим числом активных подключений.|
|**IP Hash**|Клиент всегда попадает на один и тот же сервер (полезно для сессий).|
|**Weighted**|Серверы получают трафик пропорционально их мощности (весу).|

#### **4. Где применяется балансировка нагрузки?**
- **Веб-серверы** (Nginx, Apache, Cloudflare).
- **Микросервисы и API** (Kubernetes, Docker Swarm).
- **Базы данных** (PostgreSQL, MySQL кластеры).
- **Стриминговые сервисы** (Twitch, YouTube).
- **Игровые серверы** (Steam, MMORPG).

#### **5. Популярные балансировщики нагрузки**

|Инструмент|Тип|Особенности|
|---|---|---|
|**HAProxy**|Software (L4/L7)|Самый быстрый, гибкая настройка.|
|**Nginx**|Software (L7)|HTTP-балансировка + кеширование.|
|**AWS ALB/NLB**|Cloud (L7/L4)|Интеграция с AWS, автоматическое масштабирование.|
|**Cloudflare LB**|CDN + Global LB|Геораспределённая балансировка.|

**6. Пример работы**
**Сценарий:**
- 3 сервера с веб-приложением.
- Балансировщик (HAProxy) распределяет запросы по алгоритму **Round Robin**.

**Как это выглядит:**
1. Запрос 1 → Сервер 1
2. Запрос 2 → Сервер 2
3. Запрос 3 → Сервер 3
4. Запрос 4 → Сервер 1 (цикл повторяется).

Если **Сервер 2** упал, балансировщик исключает его из ротации до восстановления.

#### **Вывод**

Балансировка нагрузки — **ключевой компонент современных высоконагруженных систем**. Она обеспечивает:  
✅ **Отказоустойчивость** (автопереключение при сбоях).  
✅ **Масштабируемость** (можно добавлять серверы).  
✅ **Оптимизацию скорости** (запросы обрабатываются быстрее).

**Выбор инструмента зависит от задачи:**
- **HAProxy** – для максимальной производительности.
- **Nginx** – если нужно кеширование.
- **AWS ALB/Cloudflare** – для облачных решений.

#### HAProxy
**HAProxy** (High Availability Proxy) — это высокопроизводительный балансировщик нагрузки и прокси-сервер для **TCP** и **HTTP**-трафика. Он используется для распределения запросов между серверами, повышения отказоустойчивости и оптимизации нагрузки.

#### **1. Основные возможности HAProxy**

✅ **Балансировка нагрузки** (Round Robin, Least Connections, Hash-based и др.).  
✅ **Поддержка HTTP/HTTPS и TCP** (можно балансировать БД, SMTP, WebSocket и др.).  
✅ **Health Checks** (проверка доступности серверов).  
✅ **Сессионная устойчивость** (Sticky Sessions).  
✅ **Обратный прокси** (может скрывать внутреннюю инфраструктуру).  
✅ **Высокая производительность** (обрабатывает миллионы запросов в секунду).  
✅ **Гибкая конфигурация** (ACL, перезапись URL, логирование).

#### **2. Архитектура и режимы работы**

**Режимы балансировки**
1. **Layer 4 (TCP)**
    - Балансировка на транспортном уровне (например, для PostgreSQL, Redis, SMTP).
    - Быстрее, но без анализа HTTP-заголовков.
2. **Layer 7 (HTTP)**
    - Балансировка на уровне приложений (может анализировать URL, cookies, headers).
    - Подходит для веб-серверов (Nginx, Apache, микросервисы).

**Алгоритмы балансировки**

|Алгоритм|Описание|
|---|---|
|**Round Robin**|Поочерёдное распределение запросов (по умолчанию).|
|**Least Connections**|Запрос идёт на сервер с наименьшим числом активных подключений.|
|**Source IP Hash**|Клиент всегда попадает на один сервер (полезно для sticky sessions).|
|**URI Hash**|Запросы с одним URI направляются на один сервер (кеширование).|
### Reverse Proxy (nginx)
**Reverse Proxy** — это сервер, который принимает запросы от клиентов и перенаправляет их на внутренние серверы (бэкенды), скрывая реальную инфраструктуру. В отличие от **Forward Proxy** (который работает от имени клиентов), Reverse Proxy действует от имени серверов.

#### **1. Зачем нужен Reverse Proxy?**
- **Балансировка нагрузки** – распределение запросов между несколькими серверами.
- **Кеширование** – ускорение ответов за счёт хранения статики (например, Nginx).
- **Защита бэкендов** – скрытие IP-адресов серверов, DDoS-защита.
- **SSL/TLS-терминация** – расшифровка HTTPS на прокси, чтобы разгрузить бэкенды.
- **Маршрутизация** – перенаправление запросов в зависимости от URL, домена или заголовков.
- **Агрегация API** – объединение нескольких сервисов под одним доменом (API Gateway).

#### **2. Как работает Reverse Proxy?**
![[Pasted image 20250524081714.png]]
1. **Клиент** отправляет запрос (например, `https://example.com`).
2. **Reverse Proxy** (например, Nginx) принимает запрос.
3. **Проверяет правила маршрутизации** (например, `/api → backend:3000`, `/static → Nginx cache`).
4. **Перенаправляет запрос** на нужный сервер (или отдаёт данные из кеша).
5. **Бэкенд** обрабатывает запрос и возвращает ответ через прокси.
6. **Reverse Proxy** отправляет ответ клиенту.
#### **3. Популярные Reverse Proxy**

|Инструмент|Особенности|
|---|---|
|**Nginx**|Высокая производительность, кеширование, HTTP/2, WebSocket.|
|**Apache**|Гибкость (`.htaccess`), модульность, но менее производителен, чем Nginx.|
|**HAProxy**|Лучший для балансировки TCP/HTTP, но нет встроенного кеширования.|
|**Traefik**|Автоматическое обнаружение сервисов (Docker, Kubernetes), Let's Encrypt.|
|**Cloudflare**|CDN + Reverse Proxy с DDoS-защитой и глобальной балансировкой.|

#### **4. Reverse Proxy vs Forward Proxy**

|Характеристика|Reverse Proxy|Forward Proxy|
|---|---|---|
|**Кто использует?**|Серверы (скрытие инфраструктуры)|Клиенты (анонимизация трафика)|
|**Пример**|Nginx перед веб-сервером|VPN, прокси для обхода блокировок|
|**SSL**|Часто терминация HTTPS|Может шифровать трафик клиента|

#### **7. Сценарии использования**
- **Веб-приложения**
    - Nginx/Apache раздают статику, а API запросы перенаправляют на бэкенд (Node.js, Django).
- **Микросервисы**
    - Traefik автоматически маршрутизирует запросы между контейнерами Docker.
- **Безопасность**
    - Cloudflare защищает серверы, скрывая их реальные IP.
- **Геораспределение**
    - CDN (Cloudflare, Akamai) используют Reverse Proxy для доставки контента с ближайшего сервера.
#### **Вывод**

Reverse Proxy — это мощный инструмент для:  
✅ **Оптимизации нагрузки** (кеш, балансировка).  
✅ **Упрощения архитектуры** (единая точка входа).  
✅ **Повышения безопасности** (DDoS-защита, SSL-терминация).
**Что выбрать?**
- **Nginx** – для веб-приложений + кеширования.
- **HAProxy** – для высоконагруженной балансировки.
- **Traefik/Cloudflare** – для облачных и микросервисных решений.
### API Gateway
**API Gateway** — это сервер, который выступает в роли единой точки входа для API, управляя запросами, маршрутизацией, аутентификацией, мониторингом и другими задачами. Он упрощает работу с микросервисами, обеспечивает безопасность и повышает производительность.

#### **1. Зачем нужен API Gateway?**

✅ **Единая точка входа** – клиенты обращаются к одному адресу вместо множества сервисов.  
✅ **Маршрутизация запросов** – перенаправление `/users` → UserService, `/orders` → OrderService.  
✅ **Аутентификация и авторизация** – проверка JWT, API-ключей, OAuth.  
✅ **Балансировка нагрузки** – распределение трафика между инстансами сервисов.  
✅ **Кеширование** – ускорение ответов за счёт хранения данных (например, Redis).  
✅ **Ограничение запросов (Rate Limiting)** – защита от DDoS и злоупотреблений.  
✅ **Трансформация данных** – конвертация XML ↔ JSON, версионирование API.  
✅ **Логирование и мониторинг** – сбор метрик (Prometheus, Grafana).

#### **2. Как работает API Gateway?**
![[Pasted image 20250524081654.png]]
1. **Клиент** отправляет запрос к API Gateway (например, `api.example.com/v1/users`).
2. **Gateway проверяет аутентификацию** (JWT, API-ключ).
3. **Маршрутизация** – запрос направляется в нужный микросервис (`UserService`).
4. **Обработка запроса** – сервис возвращает данные.
5. **Gateway кеширует ответ** (если настроено) и отправляет его клиенту.
#### **3. Популярные API Gateway**

|Инструмент|Особенности|
|---|---|
|**Kong**|На базе Nginx, плагины (JWT, Rate Limiting), поддержка Kubernetes.|
|**Apigee (Google)**|Платформа для управления API, аналитика, монетизация.|
|**AWS API Gateway**|Интеграция с Lambda, CloudFront, автоматическое масштабирование.|
|**Traefik**|Автоматическое обнаружение сервисов (Docker, K8s), Let's Encrypt.|
|**Nginx**|Простейший API Gateway с Lua-скриптами (OpenResty).|
#### **4. API Gateway vs Reverse Proxy**

|Характеристика|API Gateway|Reverse Proxy|
|---|---|---|
|**Основная роль**|Управление API|Перенаправление трафика|
|**Аутентификация**|JWT, OAuth, Keycloak|Базовая (HTTP Basic Auth)|
|**Маршрутизация**|По пути, заголовкам, версии API|По URL или IP|
|**Кеширование**|Часто (Redis, Memcached)|Реже (в основном статика)|
|**Использование**|Микросервисы, BFF-паттерн|Веб-серверы, балансировка|

#### **5. Сценарии использования**
- **Микросервисная архитектура** – агрегация множества API в один endpoint.
- **Backend for Frontend (BFF)** – отдельный Gateway для Web, Mobile, Third-party.
- **Serverless (AWS Lambda)** – AWS API Gateway + Lambda для бессерверных API.
- **Гибридные облака** – единое API для облачных и локальных сервисов.
#### **Вывод**

API Gateway — это **ключевой компонент современной API-инфраструктуры**, который:  
🔹 **Упрощает клиент-серверное взаимодействие**.  
🔹 **Защищает бэкенд-сервисы**.  
🔹 **Повышает производительность** (кеш, балансировка).

**Что выбрать?**
- **Kong/Traefik** – для self-hosted решений.
- **AWS API Gateway** – для серверless-архитектуры.
- **Nginx** – для простых сценариев.

Если у вас **микросервисы** или **сложное API** – API Gateway обязателен!
### Сбор Метрик (Prometheus)/Отображение (Grafana/ELK)
Системы мониторинга помогают отслеживать состояние инфраструктуры и приложений в реальном времени. **Prometheus** собирает метрики, а **Grafana** визуализирует их в удобных дашбордах.

#### **1. Зачем нужен сбор метрик?**
- **Выявление аномалий** (резкий рост CPU, падение памяти).
- **Оптимизация производительности** (поиск узких мест).
- **Автомасштабирование** (Kubernetes HPA на основе метрик).
- **Расследование инцидентов** (анализ истории перед сбоем).
#### **2. Prometheus: Time-Series база данных для метрик**
**Prometheus** — это open-source система мониторинга, которая:  
✅ Собирает метрики по **pull-модели** (сам опрашивает targets).  
✅ Хранит данные в **временных рядах** (time-series).  
✅ Поддерживает **многочисленные экспортеры** (Node, MySQL, Nginx).  
✅ Имеет мощный язык запросов **PromQL**.

### **Как работает Prometheus?**
1. **Targets** (сервисы, серверы) предоставляют метрики в формате `/metrics` (HTTP-эндпоинт).
2. **Prometheus Server** периодически сканирует их (по умолчанию каждые 15 сек).
3. **Alertmanager** отправляет уведомления при срабатывании правил.
![[Pasted image 20250524081848.png]]
#### **3. Экспортеры метрик**
Prometheus не собирает данные сам — для этого используются **экспортеры**:
- **Node Exporter** – метрики сервера (CPU, RAM, Disk).
- **cAdvisor** – метрики контейнеров (Docker).
- **MySQL Exporter** – статистика БД.
- **Blackbox Exporter** – проверка доступности URL.

#### **4. Grafana: Визуализация метрик**
**Grafana** — это инструмент для построения дашбордов на основе данных из Prometheus, InfluxDB и других источников.
**Основные возможности:**
- Готовые шаблоны дашбордов (Dashboard Templates).
- Поддержка **PromQL** и других языков запросов.
- Алёрты (интеграция с Slack, Email).
#### **5. Плюсы и минусы стека Prometheus + Grafana**

**Преимущества**

✅ **Гибкость** – мощный PromQL и кастомизация Grafana.  
✅ **Open-Source** – бесплатно и с активным комьюнити.  
✅ **Интеграции** – сотни экспортеров и плагинов.

**Недостатки**

❌ **Нет долгосрочного хранения** (решается Thanos/Cortex).  
❌ **Pull-модель** – не подходит для краткосрочных задач (например, логи).

#### **6. Альтернативы**
- **Elastic Stack (ELK)** – для логов и метрик (но сложнее).
- **InfluxDB + Telegraf** – альтернатива Prometheus.
- **Datadog** – платное облачное решение «всё в одном».

#### **Вывод**
1. **Prometheus** – собирает метрики и хранит их в time-series БД.
2. **Grafana** – визуализирует данные в удобных дашбордах.
3. **Экспортеры** – превращают любые данные в метрики.

**Когда выбирать этот стек?**
- Для мониторинга **серверов, Kubernetes, микросервисов**.
- Если нужны **кастомные алёрты и дашборды**.
- Для **бесплатного и масштабируемого** решения.
### CI/CD
**CI/CD** (Continuous Integration / Continuous Delivery & Deployment) — это практика автоматизации сборки, тестирования и развертывания приложений. Она ускоряет разработку, уменьшает количество ошибок и позволяет быстро выпускать обновления.

#### **1. Основные понятия**
**1.1. CI (Continuous Integration — Непрерывная интеграция)**
- **Цель:** Автоматически проверять код при каждом коммите.
- **Процесс:**
    - Разработчик пушит код в репозиторий (Git).
    - CI-сервер (GitHub Actions, Jenkins) запускает сборку и тесты.
    - Если тесты проходят — код сливается в основную ветку.

**1.2. CD (Continuous Delivery / Deployment — Непрерывная доставка/развертывание)**
- **Continuous Delivery:**
    - Код автоматически собирается и **готов к ручному развертыванию** (например, кнопка "Deploy to Prod").
- **Continuous Deployment:**
    - Код **автоматически** попадает в продакшен после успешных тестов.
#### **2. Зачем нужен CI/CD?**
✅ **Раннее обнаружение багов** (тесты запускаются при каждом коммите).  
✅ **Ускорение выхода обновлений** (автоматизация рутинных задач).  
✅ **Снижение рисков** при деплое (предсказуемый процесс).  
✅ **Легкий откат** (если что-то сломалось).
#### **3. Ключевые компоненты CI/CD**
**3.1. Инструменты**

|Инструмент|Описание|
|---|---|
|**Jenkins**|Самый популярный CI/CD-сервер (гибкость, плагины).|
|**GitHub Actions**|Встроенный CI/CD в GitHub (удобно для open-source).|
|**GitLab CI/CD**|Интегрирован в GitLab (поддержка Docker, Kubernetes).|
|**CircleCI**|Облачный CI/CD (быстрая настройка).|
|**ArgoCD**|GitOps-инструмент для развертывания в Kubernetes.|
**3.2. Этапы CI/CD-конвейера**
1. **Сборка (Build)** → `docker build`, `npm install`.
2. **Тестирование (Test)** → Юнит-тесты, интеграционные тесты.
3. **Деплой в тестовое окружение (Staging)** → Проверка в "почти продакшене".
4. **Ручное/автоматическое развертывание (Production)** → Выкатка на боевые сервера.
#### **4. Лучшие практики CI/CD**
🔹 **Держите пайплайны быстрыми** (оптимизируйте тесты).  
🔹 **Используйте артефакты** (сохраняйте собранные бинарники между этапами).  
🔹 **Тестируйте в изолированных средах** (Docker, Kubernetes).  
🔹 **Внедряйте постепенный деплой** (Canary, Blue-Green).  
🔹 **Мониторьте деплои** (Grafana + Prometheus).
#### **5. Разница между CI, CD и CD**

|Термин|Описание|
|---|---|
|**CI**|Непрерывная интеграция (автотесты при каждом коммите).|
|**CD (Delivery)**|Автоматическая подготовка к релизу (ручной деплой).|
|**CD (Deployment)**|Полностью автоматический деплой в продакшен.|

#### **6. Примеры CI/CD-сценариев**
**6.1. Веб-приложение на Kubernetes**
1. Разработчик пушит код → GitHub Actions запускает тесты.
2. После успеха собирается Docker-образ и пушится в Registry.
3. ArgoCD замечает изменения в Git-репозитории и обновляет Pod’ы в Kubernetes.
**6.2. Мобильное приложение**
4. Тесты запускаются на каждом PR.
5. После мержа в `main` собирается APK/IPA и загружается в Firebase App Distribution.
#### **7. Интеграция с другими инструментами**
- **Мониторинг:** Prometheus + Grafana (следим за успешностью деплоев).
- **Безопасность:** SonarQube (проверка уязвимостей в коде).
- **Оркестрация:** Kubernetes (для управления контейнерами в продакшене).
#### **8. Проблемы и решения**

|Проблема|Решение|
|---|---|
|Долгие тесты|Параллельный запуск, разделение на юнит/интеграционные.|
|"Дрожащие" тесты|Изоляция тестов, моки внешних сервисов.|
|Сложный откат|Blue-Green-деплой, feature-флаги.|
#### **9. Вывод**

CI/CD — это **must-have** для современной разработки. Он позволяет:  
🚀 **Быстрее выпускать фичи.**  
🛡️ **Уменьшать количество багов.**  
🔁 **Автоматизировать рутину.**
**С чего начать?**
1. Выберите инструмент (GitHub Actions / GitLab CI / Jenkins).
2. Настройте простой пайплайн (сборка + тесты).
3. Постепенно добавляйте этапы (деплой, мониторинг).

**Пример архитектуры:**
![[Pasted image 20250524082442.png]]
### Поисковые движки (Elastic)
#### **1. Что такое поисковый движок?**
**Поисковый движок** — это система для индексирования и быстрого поиска данных в больших объемах информации (тексты, документы, лог-файлы, метрики).

**Ключевые функции:**
✅ **Полнотекстовый поиск** (включая нечеткий поиск).  
✅ **Масштабируемость** (работа с Big Data).  
✅ **Поддержка сложных запросов** (фильтры, агрегации).  
✅ **Высокая скорость** (поиск за миллисекунды).
#### **2. Elasticsearch**

**Elasticsearch** — это распределенный поисковый и аналитический движок на основе Apache Lucene.

**2.1. Основные возможности**
- **RESTful API** (удобная интеграция с любым языком).
- **Поддержка JSON-документов** (NoSQL-подход).
- **Горизонтальное масштабирование** (кластеры из сотен узлов).
- **Анализ текста** (токенизация, синонимы, стемминг).
- **Агрегации** (аналог GROUP BY в SQL).

**2.2. Архитектура Elasticsearch**
![[Pasted image 20250524082702.png]]
- **Индекс (Index)** — аналог таблицы в БД.
- **Документ (Document)** — единица данных (JSON-объект).
- **Шарда (Shard)** — часть индекса (для распределенного хранения).
- **Реплика (Replica)** — копия шарды для отказоустойчивости.
**2.3. Пример запроса в Elasticsearch**
```
**Добавление документа:**
PUT /products/_doc/1
{
  "name": "iPhone 15",
  "price": 999,
  "category": "smartphones"
}
**Поиск:**
GET /products/_search
{
  "query": {
    "match": { "name": "iphone" }
  }
}
```

**2.4. Плюсы и минусы Elasticsearch**
**✔ Плюсы:**
- Очень быстрый поиск.
- Гибкость (подходит для логов, товаров, аналитики).
- Интеграция с **Kibana** (визуализация) и **Logstash** (ETL).

**❌ Минусы:**
- Сложность настройки для больших кластеров.
- Нет транзакций (как в классических БД).
#### **3. Elastic Stack (ELK)**
Elasticsearch часто используют в связке с другими инструментами:
- **Elasticsearch** — хранение и поиск.
- **Logstash** — сбор и обработка данных (например, логи).
- **Kibana** — визуализация и дашборды.
- **Beats** — легковесные агенты для сбора данных.
![[Pasted image 20250524082804.png]]

#### **4. Когда выбирать Elasticsearch?**
- **Поиск по логам** (в связке с Kibana).
- **Каталоги товаров** (интернет-магазины).
- **Аналитика в реальном времени** (например, мониторинг соцсетей).

**Когда выбрать альтернативу?**
- Нужен облачный сервис → **Algolia**.
- Простой поиск для сайта → **Meilisearch**.
- Статичные данные → **Solr**.

**Стек ELK (Elasticsearch + Logstash + Kibana)** остается стандартом для анализа логов и поиска.
### Что еще?
...
## 
### Дополнительные материалы
[Metanit полное руководство по C#](https://metanit.com/sharp/tutorial/1.1.php)
[Metanit полное руководство по Asp.Net Core](https://metanit.com/sharp/aspnet6/)

[Рефакторинг гуру](https://refactoring.guru/ru/refactoring)
[Паттерны проектирования](https://refactoring.guru/ru/design-patterns)

[Паттерный проектирования](https://codelibrary.info/books/c-sharp/patterny-proektirovaniya-dlya-c-i-platformy-net-core?highlight=WyJjIl0=)
[Рефакторинг Улучшение существующего кода](https://codelibrary.info/books/dlya-programmistov/refaktoring)

[Простое объектно-ориентированное проектирование](https://codelibrary.info/books/dlya-programmistov/prostoe-obektno-orientirovannoe-proektirovanie)
[Проектирование API](https://codelibrary.info/books/dlya-programmistov/proektirovanie-arkhitektury-api)
[Искусство чистого кода](https://codelibrary.info/best-books/c-sharp?highlight=WyJjIl0=)

[Архитектурные паттерны](https://github.com/RefactoringGuru/design-patterns-csharp)
#### Полезные ссылки
[Дорожные карты Backend](https://roadmap.sh/backend)
[Дорожная карта Asp.Net Core](https://roadmap.sh/aspnet-core)
[Алгоритмы](https://neetcode.io/roadmap)

https://www.youtube.com/watch?v=w8rRhAup4kg
https://www.youtube.com/watch?v=_8yZYhAkQjQ
https://www.youtube.com/watch?v=pFKwmEdwZZQ
https://neetcode.io/roadmap

---
## Практика
- Найдите проблему, которую можно решить через автоматизацию
- Найдите решение
- Реализуйте так, чтобы результат можно было ощутить тем кто сталкивается с проблемой
- Погладьте себя за то, что теперь вы прокачались, пройдя через все трудности
- Вернитесь на 1й шаг


---
## Упражения

---
## FAQ
Если у вас возникли вопросы по занятию или общие обратитесь к [FAQ](https://docs.google.com/spreadsheets/d/1_n-wfeDpjv3-NcWxreu7minH0JQ-ooQb9B1KtNMU0eI/edit?usp=sharing)
Возможно ответ уже находится там

Если ответа на вопрос там нет. Напишите его и я обязательно дам ответ

**Инструкция**:
1. Запросите права доступа к таблице, если у вас нет доступа
2. Если вопрос по конкретному занятию, тогда зайдите во вкладку с **названием занятия**, по которому у вас возник вопрос, иначе зайдите на вкладку **Общие**
3. Напишите Вопрос в столбце **Вопрос**
4. Напишите Фамилию Имя в столбце **Автор**
5. Повторите действия
	1. Укажите Статус Ожидает 
	2. Дождитесь ответа. У вопроса будет статус Ответ дан
	3. Если ответ требует уточнения перевидте вопрос в статус Требует уточнения и напишите комментарий в столбце Комментарий
	4. Повторите, пока не получите ответ на свой вопрос
6. Переведите ответ в статус Завершен
7. Если ответ вам помог разобраться, увеличьте число в колонке **Лайки**, это поможет понять насколько эти вопросы общие и вынести ответы в материалы курса

Спасибо, что оставили вопрос, благодаря этому курс может стать лучше

---
## Обратная связь
**Обязательная обратная связь**
Для автоматизации процесса контроля за работой учеников и улучшения курса необходимо **обязательно** оставить [обратную связь по курсу](https://docs.google.com/forms/d/e/1FAIpQLSfOZTyNNNA-GDpWapoh7g_fmHYYpO8_1ZnoWsDyQTubAHvrFw/viewform?usp=dialog)
Обратная связь обязательно с точки зрения факта отправки, но нет цели заставить вас что-то писать в ней, если вам нечего сказать.

**Необязательная обратная связь** (АНОНИМНАЯ)
Если вам есть, что сказать по занятиям, но вы по каким-то причинам не готовы этим поделиться в обязательной форме обратной связи, то буду очень благодарен, если оставите ее в [анонимной обратной связи](https://docs.google.com/forms/d/e/1FAIpQLSfvVEkllf7gLIlkZLLwKXgkLVbj2sHrX4wMT4dcCeICE-K1rQ/viewform?usp=dialog)


